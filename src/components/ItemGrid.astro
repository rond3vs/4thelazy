---
// src/components/ItemGrid.astro
import { getCollection } from 'astro:content';
import type { CollectionEntry } from 'astro:content';
import ItemCard from './ItemCard.astro';

// Extended props to support more flexible filtering
interface Props {
  tag?: string;
  limit?: number;
  contentType?: string; // Allow any content type as a string
  debug?: boolean; // Enable debug mode
  includeAllDates?: boolean; // Option to include all dates or not
}

// Enhanced resource interface to support all collection types
interface Resource {
  type: 'blog' | 'product' | 'app' | 'website'; // All supported collection types
  data: CollectionEntry<'blog'> | CollectionEntry<'products'> | CollectionEntry<'apps'> | CollectionEntry<'websites'>;
  slug: string;
  title: string;
  description: string;
  image: string;
  pubDate: Date;
  updatedDate?: Date;
  isSponsored: boolean;
  
  // Collection-specific fields
  tags?: string[];            // For blog
  categories?: string[];      // For products, apps, websites
  price?: number;             // For products, apps
  currency?: string;          // For products, apps, websites
  rating?: number;            // For products, apps, websites
  affiliateLink?: string;     // For products
  
  // App-specific fields
  platform?: string[];
  developer?: string;
  version?: string;
  isFreemium?: boolean;
  hasSubscription?: boolean;
  downloadLink?: string;
  
  // Website-specific fields
  url?: string;
  technologies?: string[];
  services?: string[];
  hasFreeTier?: boolean;
  hasPaidPlan?: boolean;
  monthlyPrice?: number;
}

const { 
  tag, 
  limit, 
  contentType = 'all', 
  debug = false,
  includeAllDates = true
} = Astro.props;

// Get all collections
const allBlogPosts = await getCollection('blog');
const allProducts = await getCollection('products');
const allApps = await getCollection('apps');
const allWebsites = await getCollection('websites');

// Collection counts for debugging
const blogCount = allBlogPosts.length;
const productCount = allProducts.length;
const appCount = allApps.length;
const websiteCount = allWebsites.length;

// Debug log
if (debug) {
  console.log("=== DEBUG: COLLECTION COUNTS ===");
  console.log(`Blog posts: ${blogCount}`);
  console.log(`Products: ${productCount}`);
  console.log(`Apps: ${appCount}`);
  console.log(`Websites: ${websiteCount}`);
  
  console.log("=== DEBUG: ALL BLOG POSTS ===");
  allBlogPosts.forEach(post => {
    console.log(`Post: ${post.slug}, Date: ${post.data.pubDate}, Tags: [${post.data.tags?.join(', ') || 'none'}]`);
  });
}

// Sort collections by publication date (newest first)
const sortedBlogPosts = allBlogPosts.sort((a, b) => 
  b.data.pubDate.valueOf() - a.data.pubDate.valueOf()
);

const sortedProducts = allProducts.sort((a, b) => {
  const dateA = a.data.pubDate || new Date();
  const dateB = b.data.pubDate || new Date();
  return dateB.valueOf() - dateA.valueOf();
});

const sortedApps = allApps.sort((a, b) => {
  const dateA = a.data.pubDate || new Date();
  const dateB = b.data.pubDate || new Date();
  return dateB.valueOf() - dateA.valueOf();
});

const sortedWebsites = allWebsites.sort((a, b) => {
  const dateA = a.data.pubDate || new Date();
  const dateB = b.data.pubDate || new Date();
  return dateB.valueOf() - dateA.valueOf();
});

// Combine and prepare all resources
let allResources: Resource[] = [];

// Map blog posts to resources
allResources = [
  ...allResources,
  ...sortedBlogPosts.map((post) => ({
    type: 'blog' as const,
    data: post,
    slug: post.slug,
    title: post.data.title,
    description: post.data.description || '',
    image: post.data.image || '/images/default-blog.png',
    pubDate: post.data.pubDate,
    updatedDate: post.data.updatedDate,
    isSponsored: post.data.isSponsored || false,
    tags: post.data.tags || []
  }))
];

// Map products to resources
allResources = [
  ...allResources,
  ...sortedProducts.map((product) => ({
    type: 'product' as const,
    data: product,
    slug: product.slug,
    title: product.data.title,
    description: product.data.description || '',
    image: product.data.image || '/images/default-product.png',
    pubDate: product.data.pubDate || new Date(),
    updatedDate: product.data.updatedDate,
    isSponsored: product.data.isSponsored || false,
    categories: product.data.categories || [],
    price: product.data.price || 0,
    currency: product.data.currency || 'USD',
    rating: product.data.rating || 0,
    affiliateLink: product.data.affiliateLink || ''
  }))
];

// Map apps to resources
allResources = [
  ...allResources,
  ...sortedApps.map((app) => ({
    type: 'app' as const,
    data: app,
    slug: app.slug,
    title: app.data.title,
    description: app.data.description || '',
    image: app.data.image || '/images/default-app.png',
    pubDate: app.data.pubDate || new Date(),
    updatedDate: app.data.updatedDate,
    isSponsored: app.data.isSponsored || false,
    categories: app.data.categories || [],
    platform: app.data.platform || [],
    price: app.data.price || 0,
    currency: app.data.currency || 'USD',
    isFreemium: app.data.isFreemium || false,
    hasSubscription: app.data.hasSubscription || false,
    version: app.data.version || '',
    developer: app.data.developer || '',
    rating: app.data.rating || 0,
    downloadLink: app.data.downloadLink || ''
  }))
];

// Map websites to resources
allResources = [
  ...allResources,
  ...sortedWebsites.map((website) => ({
    type: 'website' as const,
    data: website,
    slug: website.slug,
    title: website.data.title,
    description: website.data.description || '',
    image: website.data.image || '/images/default-website.png',
    pubDate: website.data.pubDate || new Date(),
    updatedDate: website.data.updatedDate,
    isSponsored: website.data.isSponsored || false,
    categories: website.data.categories || [],
    url: website.data.url || '',
    technologies: website.data.technologies || [],
    services: website.data.services || [],
    hasFreeTier: website.data.hasFreeTier || false,
    hasPaidPlan: website.data.hasPaidPlan || false,
    monthlyPrice: website.data.monthlyPrice || 0,
    currency: website.data.currency || 'USD',
    rating: website.data.rating || 0
  }))
];

// Sort combined resources by date
let filteredResources = allResources.sort((a, b) => b.pubDate.valueOf() - a.pubDate.valueOf());

// Filter by content type
if (contentType && contentType !== 'all') {
  filteredResources = filteredResources.filter(resource =>
    resource.type === contentType
  );
}

// Filter by tag/category
if (tag && tag !== 'all') {
  filteredResources = filteredResources.filter(resource => {
    if (resource.type === 'blog' && resource.tags) {
      return resource.tags.includes(tag);
    } else if (resource.categories) {
      return resource.categories.includes(tag);
    }
    return false;
  });
}

// Apply limit
if (limit && !tag) {
  filteredResources = filteredResources.slice(0, limit);
} else if (limit && tag) {
  filteredResources = filteredResources.slice(0, Math.max(30, limit));
}

// Get all unique tags/categories from all resources
const allTagsSet = new Set<string>();
filteredResources.forEach(resource => {
  if (resource.type === 'blog' && resource.tags) {
    resource.tags.forEach(tag => allTagsSet.add(tag));
  } else if (resource.categories) {
    resource.categories.forEach(category => allTagsSet.add(category));
  }
});
const allTags = Array.from(allTagsSet).sort();

// Calculate counts for each content type
const categoryCounts = {
  all: allResources.length,
  blog: allResources.filter(r => r.type === 'blog').length,
  product: allResources.filter(r => r.type === 'product').length,
  website: allResources.filter(r => r.type === 'website').length,
  app: allResources.filter(r => r.type === 'app').length,
};

// Calculate debug information
const totalResources = filteredResources.length;
---

<section class="resources-section">
  <div class="container">
    <h2 class="section-title">Look around. Stay Awhile. 🤩</h2>
    <p class="section-description">Explore our latest articles and tools to help you stay informed and productive.</p>
    
    {debug && (
      <div class="debug-panel">
        <h3>Debug Information</h3>
        <ul>
          <li>Blog collection: {blogCount} items</li>
          <li>Product collection: {productCount} items</li>
          <li>App collection: {appCount} items</li>
          <li>Website collection: {websiteCount} items</li>
          <li>Total resources loaded: {totalResources}</li>
          <li>Blog Posts: {categoryCounts.blog}</li>
          <li>Products: {categoryCounts.product}</li>
          <li>Websites: {categoryCounts.website}</li>
          <li>Apps: {categoryCounts.app}</li>
          <li>Current filter: {contentType}</li>
          <li>Tag filter: {tag || 'none'}</li>
          <li>Include All Dates: {includeAllDates ? 'Yes' : 'No'}</li>
        </ul>
      </div>
    )}
    
    <div class="filter-container">
      <div class="search-box">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M11 19C15.4183 19 19 15.4183 19 11C19 6.58172 15.4183 3 11 3C6.58172 3 3 6.58172 3 11C3 15.4183 6.58172 19 11 19Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M21 21L16.65 16.65" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <input type="text" id="resource-search" placeholder="Search..." />
      </div>
      
      <!-- Content type filter tabs -->
      <div class="content-type-tabs">
        <button class="content-type-tab active" data-type="all">All</button>
        <button class="content-type-tab" data-type="blog">Blog Posts</button>
        <button class="content-type-tab" data-type="product">Products</button>
        <button class="content-type-tab" data-type="website">Websites</button>
        <button class="content-type-tab" data-type="app">Apps</button>
        
        <button class="content-type-tab shuffle-button" data-action="shuffle">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-right: 4px;">
            <path d="M16 3H21V8" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M4 20L21 3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M21 16V21H16" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M15 15L21 21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M4 4L9 9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          Shuffle
        </button>
      </div>
      
      <!-- Tags filter -->
      <div class="tags-filter">
        <h3 class="filter-title">Filter by tags</h3>
        <div class="filter-tabs" id="tag-filters">
          <button class="filter-tab active" data-tag="all">ALL</button>
          {allTags.map((tagName) => (
            <button class="filter-tab" data-tag={tagName}>{tagName}</button>
          ))}
        </div>
      </div>
    </div>

    <!-- Resource cards grid -->
    <div class="resources-grid" id="resources-container">
      {filteredResources.length > 0 ? (
        filteredResources.map((resource) => {
          // Base props for all content types
          const baseProps = {
            title: resource.title,
            link: `/${resource.type}/${resource.slug}`,
            description: resource.description,
            contentType: resource.type,
            isSponsored: resource.isSponsored,
            pubDate: resource.pubDate.toISOString(),
            updatedDate: resource.updatedDate?.toISOString(),
            image: resource.image,
          };
          
          // Add specific props based on content type
          let specificProps = {};
          
          if (resource.type === 'blog') {
            specificProps = {
              tags: resource.tags || [],
              type: resource.type || '',
            };
          } 
          else if (resource.type === 'product') {
            specificProps = {
              categories: resource.categories || [],
              price: resource.price || 0,
              currency: resource.currency || 'USD',
              rating: resource.rating || 0,
              affiliateLink: resource.affiliateLink || '',
            };
          }
          else if (resource.type === 'app') {
            specificProps = {
              categories: resource.categories || [],
              platform: resource.platform || [],
              price: resource.price || 0,
              currency: resource.currency || 'USD',
              rating: resource.rating || 0,
              developer: resource.developer || '',
              version: resource.version || '',
              isFreemium: resource.isFreemium || false,
              hasSubscription: resource.hasSubscription || false,
              downloadLink: resource.downloadLink || '',
            };
          }
          else if (resource.type === 'website') {
            specificProps = {
              categories: resource.categories || [],
              url: resource.url || '',
              technologies: resource.technologies || [],
              services: resource.services || [],
              hasFreeTier: resource.hasFreeTier || false,
              hasPaidPlan: resource.hasPaidPlan || false,
              monthlyPrice: resource.monthlyPrice || 0,
              currency: resource.currency || 'USD',
              rating: resource.rating || 0,
            };
          }
          
          // Merge the base props with specific props
          const props = {...baseProps, ...specificProps};
          
          return (
            <ItemCard {...props} />
          );
        })
      ) : (
        <div class="no-resources">
          <p>No resources found matching the current filters.</p>
        </div>
      )}
    </div>
    
    <!-- Pagination -->
    <div id="pagination-container" class="pagination-container"></div>
    
    {debug && (productCount === 0 || appCount === 0 || websiteCount === 0) && (
      <div class="debug-help">
        <h3>Troubleshooting: Missing Collections</h3>
        <p>It looks like some of your collections might not have any items. Here's what to check:</p>
        <ul>
          {productCount === 0 && <li>Make sure you have created product files in <code>src/content/products/</code> directory</li>}
          {appCount === 0 && <li>Make sure you have created app files in <code>src/content/apps/</code> directory</li>}
          {websiteCount === 0 && <li>Make sure you have created website files in <code>src/content/websites/</code> directory</li>}
          <li>Ensure your content schema in <code>src/content/config.ts</code> has all collections defined</li>
          <li>Check that your content files have the correct frontmatter structure</li>
        </ul>
      </div>
    )}
  </div>
</section>

<style>
  /* * {
    border: 1px solid red;
  } */
  
  .section-title {
    margin-bottom: var(--spacing-lg);
    text-align: center;
  }
  
  .section-description {
    text-align: center;
    margin-bottom: var(--spacing-lg);
    max-width: 600px;
    margin: 0 auto var(--spacing-lg);
  }
  .container {
  position: relative;
  padding-top: 3rem;
}

  .filter-container {
    margin-bottom: var(--spacing-lg);
    
  }
  
  .search-box {
    position: relative;
    max-width: 300px;
    margin: 0 auto var(--spacing-md);
  }
  
  .search-box svg {
    position: absolute;
    left: 10px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--color-text-light);
  }
  
  .search-box input {
    padding-left: 40px;
    border-radius: var(--radius-md);
  }
  
  .content-type-tabs,
  .filter-tabs {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: var(--spacing-xs);
    margin-bottom: var(--spacing-md);
  }
  
  .content-type-tab,
  .filter-tab {
    padding: var(--spacing-sm) var(--spacing-md);
    border-radius: var(--radius-md);
    border: 1px solid var(--color-border);
    font-family: 'Roboto Mono', monospace;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.2s;
    background-color: var(--color-background);
  }
  
  .content-type-tab.active,
  .filter-tab.active {
    background-color: var(--color-primary);
    color: var(--color-white);
    font-weight: 600;
  }
  
  .content-type-tab:hover:not(.active),
  .filter-tab:hover:not(.active) {
    background-color: var(--color-white);
    color: var(--color-primary);
  }

  /* Tags Filter styles */
  .tags-filter {
    margin-top: var(--spacing-md);
  }
  
  .filter-title {
    text-align: center;
    font-size: 1.1rem;
    margin-bottom: var(--spacing-sm);
    color: var(--color-text-light);
  }
  
  /* Make the tags filter horizontally scrollable on smaller screens */
  .filter-tabs {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: var(--spacing-xs);
    margin-bottom: var(--spacing-md);
    max-width: 90%;
    margin-left: auto;
    margin-right: auto;
  }
  
  .resources-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: var(--spacing-sm);
    max-width: 100%;
    margin: 0 auto;
    width: 100%;
    min-width: 200px;
    
  }
  
  .no-resources {
    grid-column: 1 / -1;
    text-align: center;
    padding: var(--spacing-xl);
    /* background-color: var(--color-white); */
    border-radius: var(--radius-lg);
  }
  
  .debug-panel {
    background-color: #f0f8ff;
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-lg);
    border: 1px solid #b0d8ff;
  }
  
  .debug-panel h3 {
    margin-top: 0;
  }
  
  .debug-help {
    margin-top: var(--spacing-lg);
    padding: var(--spacing-md);
    background-color: #fff8f0;
    border-radius: var(--radius-md);
    border: 1px solid #ffe0b0;
  }
  
  .debug-help pre {
    background-color: #f5f5f5;
    padding: var(--spacing-sm);
    border-radius: var(--radius-sm);
    overflow-x: auto;
  }
  
  .filter-debug {
    margin-top: var(--spacing-lg);
    padding: var(--spacing-md);
    background-color: #f5f5f5;
    border-radius: var(--radius-md);
    font-family: monospace;
    display: none;
  }
  
  @media (max-width: 992px) {
    .resources-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }
  
  @media (max-width: 640px) {
    .resources-grid {
      grid-template-columns: 1fr;
    }
    
    .content-type-tabs,
    .filter-tabs {
      overflow-x: auto;
      padding-bottom: var(--spacing-sm);
      margin-bottom: var(--spacing-md);
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
    }
    
    .content-type-tabs::-webkit-scrollbar,
    .filter-tabs::-webkit-scrollbar {
      display: none;
    }
    
    .content-type-tab,
    .filter-tab {
      white-space: nowrap;
    }
  }
  
  /* Styles for the shuffle button and animations */
  .shuffle-button {
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: var(--color-white);
    color: var(--color-text);
    border: 1px dashed var(--color-border);
  }
  
  .shuffle-button:hover {
    background-color: var(--color-background-light);
    transform: rotate(5deg);
  }
  
  .shuffle-button svg {
    transition: transform 0.3s ease;
  }
  
  .shuffle-button:hover svg {
    transform: rotate(180deg);
  }
  
  /* Animation for card shuffling */
  .card.shuffled {
    transform: scale(0.95);
    opacity: 0.7;
    transition: all 0.2s ease-in-out;
  }
  
  .card.shuffle-complete {
    transform: scale(1);
    opacity: 1;
    transition: all 0.3s ease-in-out;
  }
  /* Add these styles to your existing <style> block */
    .pagination-container {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-top: var(--spacing-lg);
    gap: var(--spacing-md);
  }
  
  .pagination-button {
    padding: var(--spacing-sm) var(--spacing-md);
    border-radius: var(--radius-md);
    border: 1px solid var(--color-border);
    background-color: var(--color-white);
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: var(--spacing-xs);
  }
  
  .pagination-button:hover:not(:disabled) {
    background-color: var(--color-primary-light);
    color: var(--color-white);
  }
  
  .pagination-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .page-indicator {
    font-size: 0.9rem;
    color: var(--color-text-light);
    padding: var(--spacing-sm);
  }
  
  @media (max-width: 640px) {
    .pagination-container {
      flex-direction: column;
      gap: var(--spacing-sm);
    }
  }
</style>

<script is:inline>
  document.addEventListener('DOMContentLoaded', () => {
    // Get elements
    const contentTypeTabs = document.querySelectorAll('.content-type-tab');
    const filterTabs = document.querySelectorAll('.filter-tab');
    const resourceCards = document.querySelectorAll('.card.resource-card');
    const searchInput = document.getElementById('resource-search');
    const shuffleButton = document.querySelector('.shuffle-button');
    const resourcesContainer = document.getElementById('resources-container');
    const paginationContainer = document.getElementById('pagination-container');
    
    // Pagination settings
    const postsPerPage = 9; // Set how many posts to show per page
    let currentPage = 1;
    let filteredCards = []; // Store filtered cards for pagination
    
    let activeContentType = 'all';
    let activeTag = 'all';
    let isShuffled = false;
    
    // Debug log all available resource cards
    console.log("=== RESOURCE FILTERING DEBUG ===");
    console.log(`Found ${resourceCards.length} resource cards total`);
    
    // Process all resource cards to ensure they have proper data attributes
    resourceCards.forEach(card => {
      const title = card.querySelector('.card-title')?.textContent || 'Unknown';
      const contentType = card.getAttribute('data-content-type');
      
      // Get the tag data for logging
      const tagsStr = card.getAttribute('data-tags') || '';
      const tags = tagsStr ? tagsStr.split(',') : [];
      
      // Get the publication date for debugging
      const pubDate = card.getAttribute('data-pub-date') || 'No date';
      
      console.log(`Card: "${title}", Type: ${contentType}, Tags: [${tags.join(', ')}], Date: ${pubDate}`);
    });
    
    // Filter by content type
    contentTypeTabs.forEach(tab => {
      tab.addEventListener('click', () => {
        // Don't change active state for the shuffle button
        if (tab.getAttribute('data-action') === 'shuffle') {
          shuffleVisibleCards();
          return;
        }
        
        // Update active tab
        contentTypeTabs.forEach(t => {
          if (!t.classList.contains('shuffle-button')) {
            t.classList.remove('active');
          }
        });
        tab.classList.add('active');
        
        activeContentType = tab.getAttribute('data-type');
        console.log(`Content type filter changed to: ${activeContentType}`);
        
        // Reset to page 1 when changing filters
        currentPage = 1;
        filterResources();
      });
    });
    
    // Filter by tag/category
    filterTabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const tagValue = tab.getAttribute('data-tag');
        console.log(`Tag tab clicked: ${tab.textContent} with data-tag=${tagValue}`);
        
        // Update active tab
        filterTabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        activeTag = tagValue;
        console.log(`Tag filter changed to: ${activeTag}`);
        
        // Reset to page 1 when changing filters
        currentPage = 1;
        filterResources();
      });
    });
    
    // Filter by search term
    searchInput?.addEventListener('input', () => {
      // Reset to page 1 when searching
      currentPage = 1;
      filterResources();
    });
    
    // Create pagination controls
    function createPagination(totalItems) {
      if (!paginationContainer) return;
      
      // Clear existing pagination
      paginationContainer.innerHTML = '';
      
      // Calculate total pages
      const totalPages = Math.ceil(totalItems / postsPerPage);
      
      // Don't show pagination if only one page
      if (totalPages <= 1) {
        paginationContainer.style.display = 'none';
        return;
      }
      
      paginationContainer.style.display = 'flex';
      
      // Previous button
      const prevButton = document.createElement('button');
      prevButton.classList.add('pagination-button', 'prev-button');
      prevButton.textContent = '← Prev';
      prevButton.disabled = currentPage === 1;
      prevButton.addEventListener('click', () => {
        if (currentPage > 1) {
          currentPage--;
          updatePageDisplay();
        }
      });
      
      // Next button
      const nextButton = document.createElement('button');
      nextButton.classList.add('pagination-button', 'next-button');
      nextButton.textContent = 'Next →';
      nextButton.disabled = currentPage === totalPages;
      nextButton.addEventListener('click', () => {
        if (currentPage < totalPages) {
          currentPage++;
          updatePageDisplay();
        }
      });
      
      // Page indicator
      const pageIndicator = document.createElement('span');
      pageIndicator.classList.add('page-indicator');
      pageIndicator.textContent = `Page ${currentPage} of ${totalPages}`;
      
      // Add elements to container
      paginationContainer.appendChild(prevButton);
      paginationContainer.appendChild(pageIndicator);
      paginationContainer.appendChild(nextButton);
    }
    
    // Update page display based on current page
    function updatePageDisplay() {
      // Hide all cards first
      filteredCards.forEach(card => {
        card.style.display = 'none';
      });
      
      // Calculate start and end index for current page
      const startIndex = (currentPage - 1) * postsPerPage;
      const endIndex = Math.min(startIndex + postsPerPage, filteredCards.length);
      
      // Show cards for current page
      for (let i = startIndex; i < endIndex; i++) {
        filteredCards[i].style.display = '';
      }
      
      // Update pagination controls
      createPagination(filteredCards.length);
      
      // Scroll to top of resources container
      resourcesContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
    
    // Shuffle function to randomize visible cards
    function shuffleVisibleCards() {
      // Shuffle the filtered cards array
      for (let i = filteredCards.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        // Mark as shuffled to add animation
        filteredCards[i].classList.add('shuffled');
        filteredCards[j].classList.add('shuffled');
        // Swap elements
        [filteredCards[i], filteredCards[j]] = [filteredCards[j], filteredCards[i]];
      }
      
      // Add shuffled status to debug
      isShuffled = true;
      
      // Reset to page 1 after shuffling
      currentPage = 1;
      
      // Update display
      updatePageDisplay();
      
      // Add animation effect
      setTimeout(() => {
        filteredCards.forEach(card => {
          card.classList.remove('shuffled');
          card.classList.add('shuffle-complete');
        });
        
        setTimeout(() => {
          filteredCards.forEach(card => {
            card.classList.remove('shuffle-complete');
          });
        }, 300);
      }, 10);
    }
    
    // Enhanced filtering function
    function filterResources() {
      const searchTerm = searchInput?.value?.toLowerCase() || '';
      
      console.log(`=== FILTERING RESOURCES ===`);
      console.log(`Active content type: ${activeContentType}`);
      console.log(`Active tag: ${activeTag}`);
      console.log(`Search term: ${searchTerm}`);
      
      // Reset filtered cards array
      filteredCards = [];
      
      resourceCards.forEach(card => {
        // Get card data for filtering
        const cardContentType = card.getAttribute('data-content-type');
        const title = card.querySelector('.card-title')?.textContent || '';
        const description = card.querySelector('p')?.textContent?.toLowerCase() || '';
        
        // Get tags from data attribute
        const tagsStr = card.getAttribute('data-tags-lower') || card.getAttribute('data-tags') || '';
        const tags = tagsStr ? tagsStr.toLowerCase().split(',') : [];
        
        // Content type matching
        let contentTypeMatch = activeContentType === 'all' || cardContentType === activeContentType;
        
        // Check tag match - use case-insensitive comparison
        const activeTagLower = activeTag.toLowerCase();
        const tagMatch = activeTag === 'all' || tags.includes(activeTagLower);
        
        // Check search match
        const searchMatch = searchTerm === '' || 
                           title.toLowerCase().includes(searchTerm) || 
                           description?.includes(searchTerm) || 
                           tags.some(tag => tag.includes(searchTerm));
        
        // Apply combined filtering
        if (contentTypeMatch && tagMatch && searchMatch) {
          filteredCards.push(card);
          console.log(`✅ Card "${title}" PASSED all filters`);
        } else {
          card.style.display = 'none';
          console.log(`❌ Card "${title}" FAILED filtering`);
        }
      });
      
      // Update the page display
      updatePageDisplay();
      
      // Reset shuffle status when filter changes
      isShuffled = false;
      
      console.log(`=== FILTERING COMPLETE: ${filteredCards.length} visible items ===`);
      
      // Show a message if no results are found
      const noResultsEl = document.querySelector('.no-resources');
      if (noResultsEl) {
        noResultsEl.style.display = filteredCards.length === 0 ? 'block' : 'none';
      }
    }
    
    // Initialize filtering on load
    console.log("Initializing resource filtering...");
    filterResources();
  });
  </script>