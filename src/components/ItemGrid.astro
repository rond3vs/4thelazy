---
// src/components/ResourceGrid.astro
import { getCollection } from 'astro:content';
import type { CollectionEntry } from 'astro:content';
import ItemCard from './ItemCard.astro';

// Extended props to support filtering by content type and category
interface Props {
  tag?: string;
  limit?: number;
  contentType?: 'all' | 'blog' | 'product'; // Filter by content type
  debug?: boolean; // Enable debug mode
}

// Define a resource interface to unify both blog posts and products
interface Resource {
  type: 'blog' | 'product';
  data: CollectionEntry<'blog'> | CollectionEntry<'products'>;
  slug: string;
  contentType: string;
  title: string;
  image: string;
  description: string;
  tags: string[];
  isSponsored: boolean;
  date: Date;
}

const { tag, limit, contentType = 'all', debug = false } = Astro.props;

// Get all blog posts and products
const allBlogPosts = await getCollection('blog');
const blogCount = allBlogPosts.length;

const allProducts = await getCollection('products');
const productCount = allProducts.length;

// Sort blog posts by publication date (newest first)
const sortedBlogPosts = allBlogPosts.sort((a, b) => 
  b.data.pubDate.valueOf() - a.data.pubDate.valueOf()
);

// Sort products by publication date (newest first)
const sortedProducts = allProducts.sort((a, b) => {
  // Use pubDate if available, otherwise use current date
  const dateA = a.data.pubDate || new Date();
  const dateB = b.data.pubDate || new Date();
  return dateB.valueOf() - dateA.valueOf();
});

// Combine and prepare all resources
let allResources: Resource[] = [];

// Add blog posts with a content type identifier
if (contentType === 'all' || contentType === 'blog') {
  allResources = [
    ...allResources,
    ...sortedBlogPosts.map((post) => ({
      type: 'blog' as const,
      data: post,
      slug: post.slug,
      contentType: post.data.type,
      title: post.data.title,
      image: post.data.image || '/images/default-blog.png',
      description: post.data.description || '',
      tags: post.data.tags || [],
      isSponsored: post.data.isSponsored || false,
      date: post.data.pubDate
    }))
  ];
}

// Add products with a content type identifier
if (contentType === 'all' || contentType === 'product') {
  allResources = [
    ...allResources,
    ...sortedProducts.map((product) => ({
      type: 'product' as const,
      data: product,
      slug: product.slug,
      contentType: 'Product',
      title: product.data.title,
      image: product.data.image || '/images/default-product.png',
      description: product.data.description || '',
      tags: product.data.categories || [],
      isSponsored: product.data.isSponsored || false,
      date: product.data.pubDate || new Date()
    }))
  ];
}

// Sort combined resources by date
let filteredResources = allResources.sort((a, b) => b.date.valueOf() - a.date.valueOf());

// Filter by tag if specified
if (tag && tag !== 'all') {
  filteredResources = filteredResources.filter(resource => 
    resource.tags && resource.tags.includes(tag)
  );
}

// Limit the number of resources if specified
if (limit) {
  filteredResources = filteredResources.slice(0, limit);
}

// Get all unique tags/categories from both blogs and products for filtering
const allBlogTags = [...new Set(allBlogPosts.map((post) => post.data.tags || []).flat())] as string[];
const allProductCategories = [...new Set(allProducts.map((product) => 
  product.data.categories || []
).flat())] as string[];

// Combine all tags and categories for filtering
const allTags = [...new Set([...allBlogTags, ...allProductCategories])].sort();

// Calculate counts for debugging
const totalResources = filteredResources.length;
const blogResources = filteredResources.filter(r => r.type === 'blog').length;
const productResources = filteredResources.filter(r => r.type === 'product').length;
---

<section class="resources-section">
  <div class="container">
    <h2 class="section-title">Look around. Stay Awhile. ü§©</h2>
    <p class="section-description">Explore our latest articles and tools to help you stay informed and productive.</p>
    
    {debug && (
      <div class="debug-panel">
        <h3>Debug Information</h3>
        <ul>
          <li>Blog collection: {blogCount} items</li>
          <li>Product collection: {productCount} items</li>
          <li>Total resources loaded: {totalResources}</li>
          <li>Blog resources: {blogResources}</li>
          <li>Product resources: {productResources}</li>
          <li>Current filter: {contentType}</li>
          <li>Tag filter: {tag || 'none'}</li>
        </ul>
      </div>
    )}
    
    <div class="filter-container">
      <div class="search-box">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M11 19C15.4183 19 19 15.4183 19 11C19 6.58172 15.4183 3 11 3C6.58172 3 3 6.58172 3 11C3 15.4183 6.58172 19 11 19Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M21 21L16.65 16.65" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <input type="text" id="resource-search" placeholder="Search..." />
      </div>
      
      <!-- Content type filter -->
      <div class="content-type-tabs">
        <button class="content-type-tab active" data-type="all">All Items ({totalResources})</button>
        <button class="content-type-tab" data-type="blog">Articles ({blogResources})</button>
        <button class="content-type-tab" data-type="product">Products ({productResources})</button>
        <button class="content-type-tab" data-type="product">Websites ({productResources})</button>
        <button class="content-type-tab" data-type="product">Apps ({productResources})</button>
        
        <button class="content-type-tab shuffle-button" data-action="shuffle">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-right: 4px;">
            <path d="M16 3H21V8" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M4 20L21 3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M21 16V21H16" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M15 15L21 21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M4 4L9 9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          Shuffle
        </button>
      </div>
      
      <!-- Tags filter - NEW SECTION -->
      <div class="tags-filter">
        <h3 class="filter-title">Filter by tags</h3>
        <div class="filter-tabs" id="tag-filters">
          <button class="filter-tab active" data-tag="all">All Tags</button>
          {allTags.map((tagName) => (
            <button class="filter-tab" data-tag={tagName}>{tagName}</button>
          ))}
        </div>
      </div>
    </div>

    <!-- Resource cards grid -->
    <div class="resources-grid" id="resources-container">
      {filteredResources.length > 0 ? (
        filteredResources.map((resource) => (
          <ItemCard 
            title={resource.title}
            link={`/${resource.type}/${resource.slug}`}
            description={resource.description}
            tags={resource.tags}
            type={resource.contentType}
            isSponsored={resource.isSponsored}
            contentType={resource.type}
          />
        ))
      ) : (
        <div class="no-resources">
          <p>No resources found matching the current filters.</p>
        </div>
      )}
    </div>
    
    {debug && productCount === 0 && (
      <div class="debug-help">
        <h3>Troubleshooting: No Products Found</h3>
        <p>It looks like no product files were found in your content collection. Here's what to check:</p>
        <ul>
          <li>Make sure you have created product files in <code>src/content/products/</code> directory</li>
          <li>Ensure your content schema in <code>src/content/config.ts</code> has a products collection defined</li>
          <li>Check that your product files have the correct frontmatter structure</li>
        </ul>
        <p>Sample product frontmatter:</p>
        <pre><code>---
title: "Product Title"
description: "Product description"
pubDate: 2024-03-22
image: "/images/products/example.jpg"
categories: ["Category1", "Category2"]
isSponsored: false
---</code></pre>
      </div>
    )}
    
   
</section>

<style>
  /* * {
    border: 1px solid red;
  } */
  
  .section-title {
    margin-bottom: var(--spacing-lg);
    text-align: center;
  }
  
  .section-description {
    text-align: center;
    margin-bottom: var(--spacing-lg);
    max-width: 600px;
    margin: 0 auto var(--spacing-lg);
  }
  .container {
  position: relative;
  padding-top: 3rem;
}



  .filter-container {
    margin-bottom: var(--spacing-lg);
    
  }
  
  .search-box {
    position: relative;
    max-width: 300px;
    margin: 0 auto var(--spacing-md);
  }
  
  .search-box svg {
    position: absolute;
    left: 10px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--color-text-light);
  }
  
  .search-box input {
    padding-left: 40px;
    border-radius: var(--radius-md);
  }
  
  .content-type-tabs,
  .filter-tabs {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: var(--spacing-xs);
    margin-bottom: var(--spacing-md);
  }
  
  .content-type-tab,
  .filter-tab {
    padding: var(--spacing-sm) var(--spacing-md);
    border-radius: var(--radius-md);
    border: 1px solid var(--color-border);
    font-family: 'Roboto Mono', monospace;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.2s;
    background-color: var(--color-background);
  }
  
  .content-type-tab.active,
  .filter-tab.active {
    background-color: var(--color-primary);
    color: var(--color-white);
    font-weight: 600;
  }
  
  .content-type-tab:hover:not(.active),
  .filter-tab:hover:not(.active) {
    background-color: var(--color-white);
    color: var(--color-primary);
  }

  /* Tags Filter - NEW STYLES */
  .tags-filter {
    margin-top: var(--spacing-md);
  }
  
  .filter-title {
    text-align: center;
    font-size: 1.1rem;
    margin-bottom: var(--spacing-sm);
    color: var(--color-text-light);
  }
  
  /* Make the tags filter horizontally scrollable on smaller screens */
  .filter-tabs {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: var(--spacing-xs);
    margin-bottom: var(--spacing-md);
    max-width: 90%;
    margin-left: auto;
    margin-right: auto;
  }
  
  .resources-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: var(--spacing-sm);
    max-width: 100%;
    margin: 0 auto;
    width: 100%;
  }
  
  .no-resources {
    grid-column: 1 / -1;
    text-align: center;
    padding: var(--spacing-xl);
    /* background-color: var(--color-white); */
    border-radius: var(--radius-lg);
  }
  
  .debug-panel {
    background-color: #f0f8ff;
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-lg);
    border: 1px solid #b0d8ff;
  }
  
  .debug-panel h3 {
    margin-top: 0;
  }
  
  .debug-help {
    margin-top: var(--spacing-lg);
    padding: var(--spacing-md);
    background-color: #fff8f0;
    border-radius: var(--radius-md);
    border: 1px solid #ffe0b0;
  }
  
  .debug-help pre {
    background-color: #f5f5f5;
    padding: var(--spacing-sm);
    border-radius: var(--radius-sm);
    overflow-x: auto;
  }
  
  .filter-debug {
    margin-top: var(--spacing-lg);
    padding: var(--spacing-md);
    background-color: #f5f5f5;
    border-radius: var(--radius-md);
    font-family: monospace;
    display: none;
  }
  
  @media (max-width: 992px) {
    .resources-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }
  
  @media (max-width: 640px) {
    .resources-grid {
      grid-template-columns: 1fr;
    }
    
    .content-type-tabs,
    .filter-tabs {
      overflow-x: auto;
      padding-bottom: var(--spacing-sm);
      margin-bottom: var(--spacing-md);
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
    }
    
    .content-type-tabs::-webkit-scrollbar,
    .filter-tabs::-webkit-scrollbar {
      display: none;
    }
    
    .content-type-tab,
    .filter-tab {
      white-space: nowrap;
    }
  }
  
  /* Add these new styles for the shuffle button and animations */
  .shuffle-button {
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: var(--color-white);
    color: var(--color-text);
    border: 1px dashed var(--color-border);
  }
  
  .shuffle-button:hover {
    background-color: var(--color-background-light);
    transform: rotate(5deg);
  }
  
  .shuffle-button svg {
    transition: transform 0.3s ease;
  }
  
  .shuffle-button:hover svg {
    transform: rotate(180deg);
  }
  
  /* Animation for card shuffling */
  .card.shuffled {
    transform: scale(0.95);
    opacity: 0.7;
    transition: all 0.2s ease-in-out;
  }
  
  .card.shuffle-complete {
    transform: scale(1);
    opacity: 1;
    transition: all 0.3s ease-in-out;
  }
</style>

<script is:inline>
  document.addEventListener('DOMContentLoaded', () => {
  // Get elements
  const contentTypeTabs = document.querySelectorAll('.content-type-tab');
  const filterTabs = document.querySelectorAll('.filter-tab');
  const resourceCards = document.querySelectorAll('.card.resource-card');
  const searchInput = document.getElementById('resource-search');
  const shuffleButton = document.querySelector('.shuffle-button');
  const resourcesContainer = document.getElementById('resources-container');
  
  // Debug elements
  const currentContentTypeEl = document.getElementById('current-content-type');
  const currentTagEl = document.getElementById('current-tag');
  const currentSearchEl = document.getElementById('current-search');
  const visibleCountEl = document.getElementById('visible-count');
  const filterDebug = document.getElementById('filter-debug');
  
  // Enable debug display temporarily
  if (filterDebug) {
    filterDebug.style.display = 'block';
  }
  
  let activeContentType = 'all';
  let activeTag = 'all';
  let isShuffled = false;
  
  // Debug log all available tags
  console.log("=== RESOURCE FILTERING DEBUG ===");
  console.log(`Found ${resourceCards.length} resource cards total`);
  
  resourceCards.forEach(card => {
    const title = card.querySelector('h3')?.textContent || 'Unknown';
    const contentType = card.getAttribute('data-content-type');
    const tagElements = card.querySelectorAll('.tags span');
    const tags = Array.from(tagElements).map(tag => tag.textContent.trim());
    
    console.log(`Card: "${title}", Type: ${contentType}, Tags: [${tags.join(', ')}]`);
  });
  
  // Filter by content type
  contentTypeTabs.forEach(tab => {
    tab.addEventListener('click', () => {
      // Don't change active state for the shuffle button
      if (tab.getAttribute('data-action') === 'shuffle') {
        shuffleVisibleCards();
        return;
      }
      
      // Update active tab
      contentTypeTabs.forEach(t => {
        if (!t.classList.contains('shuffle-button')) {
          t.classList.remove('active');
        }
      });
      tab.classList.add('active');
      
      activeContentType = tab.getAttribute('data-type');
      if (currentContentTypeEl) currentContentTypeEl.textContent = activeContentType;
      console.log(`Content type filter changed to: ${activeContentType}`);
      filterResources();
    });
  });
  
  // Filter by tag/category
  filterTabs.forEach(tab => {
    tab.addEventListener('click', () => {
      console.log(`Tag tab clicked: ${tab.textContent} with data-tag=${tab.getAttribute('data-tag')}`);
      
      // Update active tab
      filterTabs.forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      
      activeTag = tab.getAttribute('data-tag');
      if (currentTagEl) currentTagEl.textContent = activeTag;
      console.log(`Tag filter changed to: ${activeTag}`);
      filterResources();
    });
  });
  
  // Filter by search term
  searchInput.addEventListener('input', () => {
    if (currentSearchEl) currentSearchEl.textContent = searchInput.value || 'none';
    filterResources();
  });
  
  // Shuffle function to randomize visible cards
  function shuffleVisibleCards() {
    const visibleCards = Array.from(resourceCards).filter(card => 
      card.style.display !== 'none'
    );
    
    console.log(`Shuffling ${visibleCards.length} visible cards`);
    
    // Fisher-Yates shuffle algorithm
    for (let i = visibleCards.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      // Mark as shuffled to add animation
      visibleCards[i].classList.add('shuffled');
      visibleCards[j].classList.add('shuffled');
      // Append to move in DOM (which changes display order)
      resourcesContainer.appendChild(visibleCards[i]);
      resourcesContainer.appendChild(visibleCards[j]);
    }
    
    // Add shuffled status to debug
    isShuffled = true;
    if (currentContentTypeEl) {
      currentContentTypeEl.textContent += ' (shuffled)';
    }
    
    // Add animation effect
    setTimeout(() => {
      visibleCards.forEach(card => {
        card.classList.remove('shuffled');
        card.classList.add('shuffle-complete');
      });
      
      setTimeout(() => {
        visibleCards.forEach(card => {
          card.classList.remove('shuffle-complete');
        });
      }, 300);
    }, 10);
  }
  
  // Combined filtering function
  function filterResources() {
    const searchTerm = searchInput.value.toLowerCase();
    let visibleCount = 0;
    
    console.log(`=== FILTERING RESOURCES ===`);
    console.log(`Active content type: ${activeContentType}`);
    console.log(`Active tag: ${activeTag}`);
    console.log(`Search term: ${searchTerm}`);
    
    resourceCards.forEach(card => {
      // Get the card's content type
      const cardContentType = card.getAttribute('data-content-type');
      
      // Get the card's title for debugging
      const title = card.querySelector('h3')?.textContent || 'Unknown';
      
      // Get tags from the card - using our specific markup
      const tagElements = card.querySelectorAll('.tags span');
      const tags = Array.from(tagElements).map(tag => tag.textContent.trim().toLowerCase());
      
      // Debug this card
      console.log(`Checking card: "${title}", Type: ${cardContentType}, Tags: [${tags.join(', ')}]`);
      
      // For search, get title and description
      const description = card.querySelector('p')?.textContent.toLowerCase() || '';
      
      // Check content type match
      const contentTypeMatch = activeContentType === 'all' || activeContentType === cardContentType;
      
      // Check tag match
      const tagMatch = activeTag === 'all' || tags.includes(activeTag.toLowerCase());
      
      // Check search match
      const searchMatch = searchTerm === '' || 
                         title.toLowerCase().includes(searchTerm) || 
                         description.includes(searchTerm) || 
                         tags.some(tag => tag.includes(searchTerm));
      
      // Log the matching results
      console.log(`- Content type match: ${contentTypeMatch}`);
      console.log(`- Tag match: ${tagMatch} (looking for "${activeTag}" in [${tags.join(', ')}])`);
      console.log(`- Search match: ${searchMatch}`);
      
      // Apply combined filtering
      if (contentTypeMatch && tagMatch && searchMatch) {
        card.style.display = '';
        visibleCount++;
        console.log(`‚úÖ Card "${title}" PASSED all filters`);
      } else {
        card.style.display = 'none';
        console.log(`‚ùå Card "${title}" FAILED filtering`);
      }
    });
    
    // Reset shuffle status when filter changes
    isShuffled = false;
    if (currentContentTypeEl) {
      currentContentTypeEl.textContent = activeContentType;
    }
    
    // Update debug counter
    if (visibleCountEl) {
      visibleCountEl.textContent = visibleCount.toString();
    }
    
    console.log(`=== FILTERING COMPLETE: ${visibleCount} visible items ===`);
    
    // Show a message if no results are found
    const noResultsEl = document.querySelector('.no-resources');
    if (noResultsEl) {
      noResultsEl.style.display = visibleCount === 0 ? 'block' : 'none';
    }
  }
  
  // Initialize filtering on load
  console.log("Initializing resource filtering...");
  filterResources();
});
</script>